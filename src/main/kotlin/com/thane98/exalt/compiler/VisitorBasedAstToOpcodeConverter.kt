package com.thane98.exalt.compiler

import com.thane98.exalt.compiler.transform.*
import com.thane98.exalt.interfaces.AstToOpcodeConverter
import com.thane98.exalt.interfaces.ExprVisitor
import com.thane98.exalt.interfaces.Opcode
import com.thane98.exalt.interfaces.StmtVisitor
import com.thane98.exalt.model.CompilerFeatures
import com.thane98.exalt.model.LiteralType
import com.thane98.exalt.model.Operator
import com.thane98.exalt.model.expr.*
import com.thane98.exalt.model.opcode.*
import com.thane98.exalt.model.stmt.*
import com.thane98.exalt.model.stmt.Label
import com.thane98.exalt.model.stmt.Return
import com.thane98.exalt.model.stmt.Yield

class VisitorBasedAstToOpcodeConverter(
    private var features: CompilerFeatures = CompilerFeatures()
): StmtVisitor<Unit>, ExprVisitor<Unit>, AstToOpcodeConverter {
    private val opcodes = mutableListOf<Opcode>()
    private var nextLabelId = 0

    companion object {
        private val builtInFunctions = mapOf(
            "streq" to StringEqualFuncallToOpcodeConverter(),
            "strne" to StringNotEqualFuncallToOpcodeConverter(),
            "fix" to FixFuncallToOpcodeConverter(),
            "float" to FloatFuncallToOpcodeConverter(),
            "printf" to PrintfFuncallToOpcodeConverter(),
            "addr" to AddrFuncallToOpcodeConverter(),
        )

        private const val autoGeneratedLabelPrefix = "__exalt__auto__generated__label__"
    }

    private fun generateLabel(): String {
        return autoGeneratedLabelPrefix + nextLabelId++
    }

    private fun generateLabelOpcode(label: String): com.thane98.exalt.model.opcode.Label {
        return com.thane98.exalt.model.opcode.Label(label)
    }

    override fun convert(stmt: Stmt, features: CompilerFeatures): List<Opcode> {
        this.features = features
        opcodes.clear()
        stmt.accept(this)
        return opcodes.toList()
    }

    override fun visitLiteral(expr: Literal) {
        opcodes.add(when (expr.literalType()) {
            LiteralType.INT -> IntLoad(expr.intValue())
            LiteralType.FLOAT -> FloatLoad(expr.floatValue())
            LiteralType.STR -> StringLoad(expr.stringValue())
        })
    }

    override fun visitGrouped(expr: Grouped) {
        expr.inner.accept(this)
    }

    override fun visitVarRef(expr: VarRef) {
        opcodes.add(if (expr.isPointer) {
            VarAddr(expr.symbol.frameId!!)
        } else {
            VarLoad(expr.symbol.frameId!!)
        })
    }

    override fun visitArrayRef(expr: ArrayRef) {
        expr.index.accept(this)
        opcodes.add(if (expr.isPointer) {
            ArrAddr(expr.symbol.frameId!!)
        } else {
            ArrLoad(expr.symbol.frameId!!)
        })
    }

    override fun visitPointerRef(expr: PointerRef) {
        expr.index.accept(this)
        opcodes.add(if (expr.isPointer) {
            PtrAddr(expr.symbol.frameId!!)
        } else {
            PtrLoad(expr.symbol.frameId!!)
        })
    }

    override fun visitUnary(expr: Unary) {
        expr.operand.accept(this)
        opcodes.add(expr.op.toOpcode())
    }

    override fun visitBinary(expr: Binary) {
        if (expr.op == Operator.LOGICAL_OR || expr.op == Operator.LOGICAL_AND) {
            visitShortCircuitedBinaryExpr(expr)
        } else {
            expr.left.accept(this)
            expr.right.accept(this)
            opcodes.add(expr.op.toOpcode())
        }
    }

    private fun visitShortCircuitedBinaryExpr(expr: Binary) {
        expr.left.accept(this)
        val endLabel = generateLabel()
        if (expr.op == Operator.LOGICAL_OR) {
            opcodes.add(LogicalOr(endLabel))
        } else {
            opcodes.add(LogicalAnd(endLabel))
        }
        expr.right.accept(this)
        opcodes.add(generateLabelOpcode(endLabel))
    }

    override fun visitFuncall(expr: Funcall) {
        val callId = expr.symbol.callId
        if (callId != null) {
            expr.args.forEach { it.accept(this) }
            opcodes.add(CallById(callId.toShort()))
        } else if (expr.symbol.name in builtInFunctions) {
            val transform = builtInFunctions[expr.symbol.name]!!
            transform.toArgs(expr).forEach { it.accept(this) }
            opcodes.add(builtInFunctions[expr.symbol.name]!!.toOpcode(expr))
        } else {
            expr.args.forEach { it.accept(this) }
            opcodes.add(CallByName(expr.symbol.name, expr.args.size.toByte()))
        }
    }

    override fun visitAssignment(expr: Assignment) {
        expr.left.isPointer = true
        expr.left.accept(this)
        expr.left.isPointer = false
        if (expr.op == Operator.ASSIGN) {
            expr.right.accept(this)
        } else {
            // Shorthand assignment ex. $0 += 5;
            opcodes.add(Dereference())
            expr.right.accept(this)
            opcodes.add(expr.op.expandShorthand().toOpcode())
        }
        opcodes.add(Assign())
    }

    override fun visitIncrement(expr: Increment) {
        if (expr.isPrefix) {
            expr.operand.isPointer = true
            expr.operand.accept(this)
            expr.operand.isPointer = false
            opcodes.add(expr.op.toOpcode())
            expr.operand.accept(this)
        } else {
            expr.operand.accept(this)
            expr.operand.isPointer = true
            expr.operand.accept(this)
            expr.operand.isPointer = false
            opcodes.add(expr.op.toOpcode())
        }
    }

    override fun visitBlock(stmt: Block) {
        stmt.contents.forEach { it.accept(this) }
    }

    override fun visitExprStmt(stmt: ExprStmt) {
        stmt.expr.accept(this)
        if (stmt.expr !is Assignment && !isBuiltInFuncall(stmt.expr)) {
            opcodes.add(Consume())
        }
    }

    private fun isBuiltInFuncall(expr: Expr): Boolean {
        return expr is Funcall && expr.symbol.name in builtInFunctions
    }

    override fun visitFor(stmt: For) {
        val stepLabel = generateLabel()
        val checkLabel = generateLabel()
        val doneLabel = generateLabel()
        stmt.init.accept(this)
        opcodes.add(Jump(checkLabel))
        opcodes.add(generateLabelOpcode(stepLabel))
        stmt.step.accept(this)
        opcodes.add(generateLabelOpcode(checkLabel))
        stmt.check.accept(this)
        opcodes.add(JumpZero(doneLabel))
        stmt.body.accept(this)
        opcodes.add(Jump(stepLabel))
        opcodes.add(generateLabelOpcode(doneLabel))
    }

    override fun visitGoto(stmt: Goto) {
        opcodes.add(Jump(stmt.symbol!!.name))
    }

    override fun visitIf(stmt: If) {
        stmt.condition.accept(this)
        val doneLabel = generateLabel()
        val elseLabel = if (stmt.elsePart != null) generateLabel() else null
        val firstLabel = elseLabel ?: doneLabel
        opcodes.add(JumpZero(firstLabel))
        stmt.thenPart.accept(this)
        if (stmt.elsePart != null) {
            opcodes.add(Jump(doneLabel))
            opcodes.add(generateLabelOpcode(elseLabel!!))
            stmt.elsePart.accept(this)
        }
        opcodes.add(generateLabelOpcode(doneLabel))
    }

    override fun visitLabel(stmt: Label) {
        opcodes.add(generateLabelOpcode(stmt.symbol.name))
    }

    override fun visitMatch(stmt: Match) {
        stmt.switch.accept(this)
        val doneLabel = generateLabel()
        var nextCaseLabel: String? = null
        for (case in stmt.cases) {
            if (nextCaseLabel != null)
                opcodes.add(generateLabelOpcode(nextCaseLabel))

            // Write the check.
            opcodes.add(Duplicate())
            case.condition.accept(this)
            opcodes.add(Equal())

            val blockLabel = generateLabel()
            nextCaseLabel = if (case == stmt.cases.last() && stmt.default == null)
                doneLabel
            else
                generateLabel()
            opcodes.add(JumpNotZero(blockLabel))
            opcodes.add(Jump(nextCaseLabel))

            opcodes.add(generateLabelOpcode(blockLabel))
            case.body.accept(this)
            opcodes.add(Jump(doneLabel))
        }
        if (stmt.default != null) {
            if (nextCaseLabel != null) {
                opcodes.add(generateLabelOpcode(nextCaseLabel))
            }
            stmt.default?.accept(this)
            opcodes.add(Jump(doneLabel))
        }
        opcodes.add(generateLabelOpcode(doneLabel))
        opcodes.add(Consume())
    }

    override fun visitReturn(stmt: Return) {
        val value = stmt.value
        if (value is Literal && value.intValueOrNull() == 1) {
            opcodes.add(ReturnTrue())
        } else if (value is Literal && value.intValueOrNull() == 0) {
            opcodes.add(ReturnFalse())
        } else {
            value.accept(this)
            opcodes.add(com.thane98.exalt.model.opcode.Return())
        }
    }

    override fun visitWhile(stmt: While) {
        val checkLabel = generateLabel()
        val doneLabel = generateLabel()
        opcodes.add(generateLabelOpcode(checkLabel))
        stmt.condition.accept(this)
        opcodes.add(JumpZero(doneLabel))
        stmt.body.accept(this)
        opcodes.add(Jump(checkLabel))
        opcodes.add(generateLabelOpcode(doneLabel))
    }

    override fun visitYield(stmt: Yield) {
        opcodes.add(com.thane98.exalt.model.opcode.Yield())
    }
}